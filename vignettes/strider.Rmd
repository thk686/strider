---
title: "The Strider Package"
author: "Timothy H. Keitt"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

"I don't think he knows about second breakfast" - Meriadoc 'Merry' Brandybuck

## Introduction

The **strider** package implements a pointer-based strided iterator for use with legacy buffers. It is implemented as a stand-alone C++11 header that depends on the [C++ standard library](http://en.cppreference.com/w/) and [Boost iterator facade](http://www.boost.org/doc/libs/release/libs/iterator/). The **strided_pointer** iterator class and associated functions allow adaptation of multidimensional arrays for use with iterator-based algorithms. Although packaged with R, the header file can be used independently of R. Please provide the appropriate citation in any event.

## Implementation

The **strided_pointer** template is as minimalist as possible. It inherits from Boost's **iterator_facade** and holds only a pointer to the template type and a stride. Upon specialization, **strided_pointer** conforms to the **RandomAccessIterator** concept. It is currently possible to specify negative strides, however this is not tested.

## Usage

The **strided_pointer** and related functions are designed to be used in C++ code. I first create a header to avoid some repetitive code declarations. Unfortunately, Rcpp attributes cannot be used in a header and are included in the code examples below. The dependency on BH is only to fix a problem with Travis CI. For sake of brevity, the header contents are omitted here. They can be found in the original markdown file.

```{r echo=FALSE}
header_code = '
#include <Rcpp.h>
using Rcpp::stop;
using Rcpp::IntegerVector;
using Rcpp::NumericVector;
using Rcpp::NumericMatrix;
using Rcpp::Dimension;
using Rcpp::Rcout;
using Rcpp::wrap;

#include <strider.h>
using strider::make_stri_range;
using strider::stri_begin;
using strider::stri_end;

#include <algorithm>
using std::accumulate;
using std::transform;
using std::for_each;

#include <vector>
using std::vector;
'

header_file = "vignette.h"
cat(header_code, file = file.path(tempdir(), header_file))
pkg_cppflags = Sys.getenv("PKG_CPPFLAGS")
pkg_cppflags = paste(pkg_cppflags, paste0("-I\"", tempdir(), "\""))
Sys.setenv(PKG_CPPFLAGS = pkg_cppflags)
```

### Column sums

As a minimal example, consider computing the column sums of a matrix. Many authors familiar with C would implement this using for-loops.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector indx_col_sum(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nc, 0.0);
  for (int c = 0; c != nc; ++c)
    for (int r = 0; r != nr; ++r)
      res(c) += x(r, c);
  return res;
}
```

```{r echo=FALSE}
local({
x = matrix(1:1e4, 1e2)
if (!identical(indx_col_sum(x), colSums(x)))
  stop("indx_col_sum is incorrect")
})
```

This code is suboptimal for a number of reasons. For one, each vector and matrix access requires computing pointer offsets into the underlying buffer. The results below show that this implementation is much slower than R's built-in ```colSums``` function.

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(microbenchmark)
```

```{r}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(colSums(x), indx_col_sum(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 2)
```

An alternative to for-loops are the C++ standard library algorithms. These are generally difficult to use with multidimensional data. This is why I wrote **strider**. For multidimensional data, we need to iterate over the columns, then the rows. To do this, we construct a **strided_pointer** that skips to the first element of each column. From there, we can accumulate the values easily. The standard library algorithms required are ```transform``` and ```accumulate```. 

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector stri_col_sum(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  auto data = &x[0];
  NumericVector res(nc);
  transform(stri_begin(data, nr), stri_end(data, nr, nc), &res[0],
            [&](const double& v){ return accumulate(&v, &v + nr, 0.0); });
  return res;
}
```

```{r echo=FALSE}
local({
x = matrix(1:1e4, 1e2)
if (!identical(stri_col_sum(x), colSums(x)))
  stop("stri_col_sum is incorrect")
})
```

The main functions above are ```stri_begin``` and ```stri_end```, which create starting and ending iterators over the columns of data. This is a fairly efficient implementation as shown below.

```{r}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(colSums(x), indx_col_sum(x), stri_col_sum(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 2)
```

This version is in a dead-heat with the built-in ```colSums``` function.

### Row sums

Summing over rows is more interesting because R matrices are stored in column-major format. That means that looping over a row will skip from column to column by-passing all the rows in between. This non-local memory access is a drag on performance.

Again, we can implement in terms of for-loops with a slight change.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector indx_row_sum(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nr, 0.0);
  for (int c = 0; c != nc; ++c)
    for (int r = 0; r != nr; ++r)
      res(r) += x(r, c);
  return res;
}
```

```{r echo=FALSE}
local({
x = matrix(1:1e4, 1e2)
if (!identical(indx_row_sum(x), rowSums(x)))
  stop("indx_row_sum is incorrect")
})
```

We are still looping over columns first, which is more efficient, yet this is still a slow implementation.
 
```{r}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(rowSums(x), indx_row_sum(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 2)
```

As before, we can reimplement using **strider** and the standard library algorithms. A naive implementation will stride over the rows, then columns.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector stri_row_sum(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  auto data = &x[0];
  NumericVector res(nr);
  transform(data, data + nr, &res[0], [&](const double& v){
    return accumulate(stri_begin(&v, nr), stri_end(&v, nr, nc), 0.0); });
  return res;
}
```

```{r echo=FALSE}
local({
x = matrix(1:1e4, 1e2)
if (!identical(stri_row_sum(x), rowSums(x)))
  stop("stri_row_sum is incorrect")
})
```

While this code is compact, notice that the strided pointer is in the inner loop. This non-sequential memory access will slow down the algorithm.

```{r}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(stri_row_sum(x), rowSums(x), indx_row_sum(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 2)
```

The results are not bad, matching the timing of R's built-in ```rowSums```, but is still twice as slow as summing columns owing to the skipping over rows.

An optimal version of this algorithm would iterate over the matrix in column-major order to avoid non-sequential memory access. For that, we need the binary-function version of ```transform```.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector stri_row_sum2(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nr, 0.0);
  auto data = &x[0];
  auto rptr = &res[0];
  for_each(stri_begin(data, nr),
           stri_end(data, nr, nc),
           [&](const double& x){
             transform(&x, &x + nr, rptr, rptr,
                       [](const double& a, const double& b){
                         return a + b; });});
  return res;
}
```

```{r echo=FALSE}
local({
x = matrix(1:1e4, 1e2)
if (!identical(stri_row_sum2(x), rowSums(x)))
  stop("stri_row_sum2 is incorrect")
})
```

This code is similar to the column summing algorithm in that the inner loop is sequential access. The outer ```for_each``` loop jumps to the top of each column, while the inner ```transform``` loop scans the rows and adds the values to the running sums stored in the result vector.

```{r}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(stri_row_sum(x), rowSums(x),
               indx_row_sum(x), stri_row_sum2(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 2)
```

The speed-up is quite remarkable, roughly three times faster than R's native ```rowSums``` and even faster than R's built-in ```colSums``` function. The performance is due to excellent locality and, perhaps, the ```for_each``` loop was unrolled by the compiler. Notice that the inner-loop ends exactly at the next position of the outer-loop, perhaps allowing some additional optimization.

Experimenting with this code suggests that lambda capture-by-value versus capture-by-reference has no impact on performance. However, using pass-by-value for the lambda arguments causes a dramatic slowdown. This is undoubtedly an issue with function inlining or other compiler optimizations.

We might be curious whether it is possible increase the efficiency of the column summing to match the result for our transform-based row sum algorithm. We can trick ```transform``` into accumulating using a 0-stride iterator.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector stri_col_sum2(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nc, 0.0);
  auto data = &x[0];
  auto rptr = &res[0];
  transform(stri_begin(data, nr), stri_end(data, nr, nc), rptr, rptr,
            [&](const double& x, double& y){
              transform(&x, &x + nr, stri_begin(&y, 0), stri_begin(&y, 0),
                        [](const double& a, const double& b){
                          return a + b; });
              return y; });
  return res;
}
```

```{r echo=FALSE}
local({
x = matrix(1:1e4, 1e2)
if (!identical(stri_col_sum2(x), colSums(x)))
  stop("stri_col_sum2 is incorrect")
})
```

The 0-stride iterator uses ```y``` to accumulate the column sum and this is returned and assigned to ```rptr```, which is iterated forward for each column.

```{r}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(colSums(x), indx_col_sum(x),
               stri_col_sum(x), stri_col_sum2(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 2)
```

This version is no more efficient than the ```accumulate``` version. Perhaps there is something intrinsicly faster about row sums, or, more likely, the compiler handles ```for_each``` very efficiently. Figure 1. plots the observed runtimes for comparison.


```{r fig.width = 6, fig.height = 4}
library(ggplot2)
x = matrix(rnorm(1e6), 1e3)
mb = microbenchmark(stri_row_sum2(x), stri_row_sum(x), rowSums(x),
                    colSums(x), stri_col_sum(x), stri_col_sum2(x),
                    indx_row_sum(x), indx_col_sum(x))
autoplot(mb) + theme_classic()
```

## Range-based for loops

In addition to ```stri_begin``` and ```stri_end```, **strider** provides a strided range for range-based for-loops.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
SEXP stri_nth_values(const IntegerVector& x, int stride, int strides)
{
  vector<int> res;
  for (auto&& v : make_stri_range(&x[0], stride, strides)) res.push_back(v);
  return wrap(res);
}
```

The ```make_stri_range``` simply encapsulates calls to ```stri_begin``` and ```stri_end```. It is currently a very minimal implementation. There is no boundary checking, so improper use will cause heap corruption. Other than ```begin``` and ```end``` methods, a range concept is not yet a part of the standard library. See however [Boost Range v2](http://www.boost.org/doc/libs/release/libs/range/) and the [range-v3 proposal](https://github.com/ericniebler/range-v3). Both implement strided iterators over ranges, but would not be considered light-weight.

```{r}
stri_nth_values(1:1000, 21, 11)
```

A strided range can be used to loop over all elements of an arbitrarily dimensioned array with extents only known at runtime.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
void stri_loop_range_3(const IntegerVector& a)
{
  IntegerVector d = a.attr("dim");
  if (d.size() != 3) stop("Expecting 3D array");
  for (auto&& x : make_stri_range(&a[0], d[1] * d[2], d[0]))
    for (auto&& y : make_stri_range(&x, d[2], d[1]))
      for (auto&& z : make_stri_range(&y, 1, d[2]))
        Rcout << x << " " << y << " " << z << std::endl;
}
```

Properly constructed, the stride should diminish with each added inner-loop to optimize memory locality.

```{r}
x = 1:(2 * 2 * 2)
dim(x) = c(2, 2, 2)
stri_loop_range_3(x)
```

## Conclusions

Experimenting with the C++ standard library algorithms demonstrates that they are often highly efficient and, in some cases, faster than corresponding native R algorithms. However using the standard library algorithms with multidimensional data is challenging and it is quite common for authors to resort to index-based for-loops, which can impede performance.

The **strider** package provides a lightweight pointer-adapter that makes using the standard library algorithms straightforward with multidimensional buffers accessible via a pointer. As long as one knows the dimensions and the memory layout of the data, then any dimension can be scanned by computing a stride and number of strides. When it is possible to scan the data sequentially, maximum performance is attained. Owning to the large number of legacy libraries whose APIs pass raw pointers to structured buffers, I expect that **strider** may find a wide range of applications while also improving code reliability and comprehension.

***

