---
title: "The Strider Package"
author: "Timothy H. Keitt"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(microbenchmark)

#knitr::opts_chunk$set(cache=TRUE)

header_code = '
#include <Rcpp.h>
using Rcpp::stop;
using Rcpp::IntegerVector;
using Rcpp::NumericVector;
using Rcpp::NumericMatrix;
using Rcpp::Dimension;
using Rcpp::Rcout;
using Rcpp::Fast;
using Rcpp::wrap;

#include <strider.h>
using strider::make_strided_range;
using strider::make_strided;

#include <algorithm>
using std::accumulate;
using std::transform;
using std::for_each;
using std::begin;
using std::end;

#include <vector>
using std::vector;
'

header_file = "vignette.h"
cat(header_code, file = file.path(tempdir(), header_file))
pkg_cppflags = Sys.getenv("PKG_CPPFLAGS")
pkg_cppflags = paste(pkg_cppflags, paste0("-I\"", tempdir(), "\""))
Sys.setenv(PKG_CPPFLAGS = pkg_cppflags, MAKE = "make -j2")
```

"I don't think he knows about second breakfast" - Meriadoc 'Merry' Brandybuck

## Introduction

The [C++ standard library](http://en.cppreference.com/w/) introduced generic algorithms that operate on a sequences defined by begin-end iterator-pairs. These generic algorithms can be used to replace C-style for-loops over indices. They are thought to reduce common code bugs resulting from off-by-n indexing errors that can result in buffer overruns and other illogical behaavior. Applying the standard library algorithms is often straitforward for simple sequences bounded by iterators. When working with multidimensional data like matrices however, many authors revert to computing indices, either because it is more explicit and thefore easier to implement or because the multidimensional data structures do not offer pre-defined iterators.

The difficulty applying the standard library algorithms to multidimensional data stems from the fact that successive dimensions must follow leading dimensions and this necessitates skips when iterating. Solving this requires a strided iterator that skips over intermediate memory locations when incrementing or decrementing. Having myself often reverted to indices when implementing algorithms on multidimesional data, while simultaneously wishing for more consistency with the standard library, I decided to implement a strided pointer class and wrap it in the new R library **strider**. The header is installed with the package, so it can be used by other packages via the LinkingTo directive in the DESCRIPTION file. The header has no dependencies on R and so can be used separately.

### Replacing index loops with standard library algorithms

As a prelude to using the **strided_iterator** class, I start out with an example of vector convolution because it is one of the original examples in the [Rcpp](https://github.com/RcppCore/Rcpp) documentation, which I have copied verbatim here. I have place some definitions into a header file whose contents can be found in the RMarkdown source file used to generate this output. Otherwise, all compiler settings were left at their default values.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector
convolve_cpp(const NumericVector& a,
             const NumericVector& b) {
  // Declare loop counters, and vector sizes
  int i, j,
      na = a.size(), nb = b.size(),
      nab = na + nb - 1;
  // Create vector filled with 0
  NumericVector ab(nab);
  // Crux of the algorithm
  for(i = 0; i < na; i++) {
    for(j = 0; j < nb; j++) {
          ab[i + j] += a[i] * b[j];
    }
  }
  // Return result
  return ab;
}
```

The next code block shows my translation using the standard library transform algorithm. This version eschews integer indexes for incrementing iterators along the input and output vectors.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector
stl_algo_convolve(const NumericVector& a,
                  const NumericVector& b) {
  // Declare vector sizes
  int
    na = a.size(), nb = b.size(), 
    nab = na + nb - 1;
  // Create vector filled with 0
  NumericVector ab(nab);
  // Crux of the algorithm
  transform(begin(a), end(a),
            begin(ab), begin(ab),
            [&](const double& t, double& u){
              transform(begin(b), end(b), &u, &u,
                        [&](const double& v, const double& w){
                          return w + t * v; });
              return u; });
  // Return result
  return ab;
}
```

```{r, include=FALSE}
a = sample(1:1e2)
b = sample(1:1e2)
if (!identical(convolve_cpp(a, b), stl_algo_convolve(a, b)))
  stop("stl_algo_convolve is incorrect")
```

While the code is certainly more busy, replacing explicit loops with standard library algorithms is considered by some to be a best-practice that is less susceptible to indexing errors and buffer overruns.

C++11 introduced range-based for-loops that many of the advantages of the standard library algorithms in terms of avoiding indexing errors and are simpler and somewhat more natural to reason about.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector
range_loop_convolve(const NumericVector& a,
                    const NumericVector& b) {
  // Declare vector sizes
  int
    na = a.size(), nb = b.size(), 
    nab = na + nb - 1;
  // Create vector filled with 0
  NumericVector ab(nab);
  // Crux of the algorithm
  auto t = &ab[0];
  for (auto&& u : a)
  {
    auto v = t++;
    for (auto&& w : b)
      *v++ += u * w;
  }
  // Return result
  return ab;
}
```

```{r, include=FALSE}
a = sample(1:1e2)
b = sample(1:1e2)
if (!identical(convolve_cpp(a, b), range_loop_convolve(a, b)))
  stop("range_loop_convolve is incorrect")
```

The main difference here is we have to manually increment the output iterator. That could be solved using a zip iterator adaptor. (Convenient tuple syntax for this case is available in C++17.) Nonetheless, this example demonstrates how expressive range-based for-loops can be while avoiding explicit indices.

There is no particular performance advantage to avoiding indices, so the choice is largely a matter of taste. Modern compilers will produce similar if not the exact same instructions regardless of the type of loop. Benchmarking comparisons can however point out problems with a particular implementation. It is useful to recall that benchmark differences within $\pm 10$% are likely meaningless and results will vary in different environments. With two vectors of length $10^3$, I get the following run times for the different loop implementations.

```{r echo=FALSE}
a = sample(1:1e3)
b = sample(1:1e3)
microbenchmark(convolve_cpp(a, b),
               stl_algo_convolve(a, b),
               range_loop_convolve(a, b)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>% arrange(median) %>%
  knitr::kable(digits = 1, caption = "Run time (milliseconds)")
```

## Usage

The workhorse class in the **strider** package is **strided_iterator**, which inherits from the [Boost iterator adaptor](http://www.boost.org/doc/libs/release/libs/iterator/) class. It merely advances by a specified stride when incremented. It is currently possible to use negative strides, however this is not 
tested. The strided iterator will conform to the same iterator category and support the same expressions as the iterator that is adapted. A second class, **iterator_range** exists solely to construct begin and end iterators over a strided range.

Users will generally only need to call one or both of two auxilliary functions with the following definitions:

```{cpp}
template<typename T>
inline strided_iterator<T>
make_strided(T iter,
             typename iterator_traits<T>::difference_type stride = 0,
             typename iterator_traits<T>::difference_type strides = 0);

template<typename T>
inline strided_range<T>
make_strided_range(T iter,
                   typename iterator_traits<T>::difference_type stride,
                   typename iterator_traits<T>::difference_type strides);
```

The ```make_strided``` function converts an ordinary iterator to a strided iterator. The stride length is determined by the ```stride``` argument. As a convenience, the ```strides``` argument can be used to advance the supplied iterator ```strides``` $\times$ ```stride``` steps. This is useful in creating an end-sentinel iterator for a buffer that does not provide its own ```end``` function. Examples of this useage can be found belows.

The ```make_strided_range``` function creates a ```strided_range``` object with ```begin``` and ```end``` methods. Both ```stride``` and ```strides``` are required to define the spanned range.

### Striding over matrix margins

As a minimal example, consider computing the column sums of a matrix. I provide three example implementations using indices, ```make_strided``` and ```make_strided_range```.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector indx_col_sum(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nc, 0.0);
  for (int c = 0; c != nc; ++c)
    for (int r = 0; r != nr; ++r)
      res[c] += x(r, c);
  return res;
}

// [[Rcpp::export]]
NumericVector strided_col_sum(const NumericMatrix& x)
{
  auto nr = x.nrow();
  NumericVector res(x.ncol());
  transform(make_strided(begin(x), nr), make_strided(end(x)), begin(res),
            [&](const double& v){ return accumulate(&v, &v + nr, 0.0); });
  return res;
}

// [[Rcpp::export]]
NumericVector range_col_sum(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nc);
  auto t = res.begin();
  for (auto&& u : make_strided_range(begin(x), nr, nc))
  {
    for (auto&& v : make_strided_range(&u, 1, nr)) *t += v;
    ++t;
  }
  return res;
}
```

```{r include=FALSE}
local({
x = matrix(1:1e4, 1e2)
if (!identical(indx_col_sum(x), colSums(x)))
  stop("indx_col_sum is incorrect")
if (!identical(strided_col_sum(x), colSums(x)))
  stop("strided_col_sum is incorrect")
if (!identical(range_col_sum(x), colSums(x)))
  stop("range_col_sum is incorrect")
})
```

In this case, owing to the column-major memory layout of R matrices, the STL ```transform``` algorithm combined with ```make_strided``` is the most compact in terms of code. Furthermore, the strided iterator is incremented in the outer loop meaning the scanning of the matrix is in the optimal order. The performance of these three implementations are equivalent, as is R's built in ```colSumms``` implemented in C.

```{r echo=FALSE}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(colSums(x), indx_col_sum(x),
               strided_col_sum(x), range_col_sum(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>% arrange(median) %>%
  knitr::kable(digits = 1, caption = "Run time (milliseconds)")
```


### Row sums

Summing over rows is more interesting because R matrices are stored in column-major format. That means that looping over a row will skip from column to column by-passing all the rows in between. This non-local memory access is a drag on performance. Four implementations of the row-summing algorithm are given below. 

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
NumericVector indx_row_sum(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nr, 0.0);
  for (int c = 0; c != nc; ++c)
    for (int r = 0; r != nr; ++r)
      res[r] += x(r, c);
  return res;
}

// [[Rcpp::export]]
NumericVector strided_row_sum(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nr);
  transform(begin(x), begin(x) + nr, begin(res), [&](const double& v){
    return accumulate(make_strided(&v, nr), make_strided(&v, nr, nc), 0.0); });
  return res;
}

// [[Rcpp::export]]
NumericVector strided_row_sum2(const NumericMatrix& x)
{
  auto nr = x.nrow();
  NumericVector res(nr, 0.0);
  for_each(make_strided(begin(x), nr), make_strided(end(x)),
           [&](const double& y){
             transform(&y, &y + nr, begin(res), begin(res),
                       [](const double& a, const double& b){
                         return a + b; });});
  return res;
}

// [[Rcpp::export]]
NumericVector range_row_sum(const NumericMatrix& x)
{
  auto
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nc);
  for (auto&& u : make_strided_range(begin(x), nr, nc))
  {
    auto t = begin(res);
    for (auto&& v : make_strided_range(&u, 1, nr)) *t++ += v;
  }
  return res;
}
```

Again, the ```transform``` with ```accumulate``` implementation is compact, but here the strided iterator is in the innner loop causing poor memory locality. The alternative implementation uses ```for_each``` with ```make_strided``` to skip to the top of each column and then uses ```transform``` to accumulate the values. The final range-based version is equivalent to the ```for_each``` with ```transform``` version.

```{r include=FALSE}
local({
x = matrix(1:1e4, 1e2)
if (!identical(indx_row_sum(x), rowSums(x)))
  stop("indx_row_sum is incorrect")
if (!identical(strided_row_sum(x), rowSums(x)))
  stop("strided_row_sum is incorrect")
if (!identical(strided_row_sum2(x), rowSums(x)))
  stop("strided_row_sum2 is incorrect")
if (!identical(range_row_sum(x), rowSums(x)))
  stop("range_row_sum is incorrect")
})
```

The benchmark results show that indeed placing the strided iterator in the inner loop gives poor results. The index-based, range-based and ```for_each```-```transform``` version are all equivalent in efficiency. Interestingly, R's built in ```rowSums``` is three times slower, most likely indicating that the column index is incremented in the inner loop.

```{r echo=FALSE}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(strided_row_sum(x), rowSums(x),
               indx_row_sum(x), strided_row_sum2(x),
               range_row_sum(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 1, caption = "Run time (milliseconds)")
```


We are still looping over columns first, which is more efficient, yet this is still a slow implementation.
 
```{r}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(rowSums(x), indx_row_sum(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 1)
```

As before, we can re-implement using **strider** and the standard library algorithms. A naive implementation will stride over the rows, then columns.



While this code is compact, notice that the strided pointer is in the inner loop. This non-sequential memory access will slow down the algorithm.

```{r}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(strided_row_sum(x), rowSums(x), indx_row_sum(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 1)
```

The results are not bad, matching the timing of R's built-in ```rowSums```, but is still twice as slow as summing columns owing to the skipping over rows.

An optimal version of this algorithm would iterate over the matrix in column-major order to avoid non-sequential memory access. For that, we need the binary-function version of ```transform```.


This code is similar to the column summing algorithm in that the inner loop is sequential access. The outer ```for_each``` loop jumps to the top of each column, while the inner ```transform``` loop scans the rows and adds the values to the running sums stored in the result vector.

```{r}
x = matrix(rnorm(1e6), 1e3)
microbenchmark(strided_row_sum(x), rowSums(x),
               indx_row_sum(x), strided_row_sum2(x)) %>%
  summary(unit = "ms") %>% select(expr, median) %>%
  mutate(ratio = median / min(median)) %>%
  arrange(median) %>% knitr::kable(digits = 1)
```

The speed-up is quite remarkable, roughly three times faster than R's native ```rowSums``` and even faster than R's built-in ```colSums``` function. The performance is due to excellent locality and, perhaps, the ```for_each``` loop was unrolled by the compiler. Notice that the inner-loop ends exactly at the next position of the outer-loop, perhaps allowing some additional optimization.

Experimenting with this code suggests that lambda capture-by-value versus capture-by-reference has no impact on performance. However, using pass-by-value for the lambda arguments causes a dramatic slowdown. This is undoubtedly an issue with function inlining or other compiler optimizations.

```{r fig.width = 6, fig.height = 4}
library(ggplot2)
x = matrix(rnorm(1e6), 1e3)
mb = microbenchmark(strided_row_sum2(x), strided_row_sum(x), rowSums(x),
                    colSums(x), strided_col_sum(x), indx_row_sum(x), 
                    indx_col_sum(x))
autoplot(mb) + theme_classic()
```

## Range-based for loops

In addition to ```strided_begin``` and ```strided_end```, **strider** provides a strided range for range-based for-loops.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
SEXP strided_nth_values(const IntegerVector& x, int stride, int strides)
{
  vector<int> res;
  for (auto&& v : make_strided_range(&x[0], stride, strides)) res.push_back(v);
  return wrap(res);
}
```

The ```make_strided_range``` simply encapsulates calls to ```strided_begin``` and ```strided_end```. It is currently a very minimal implementation. There is no boundary checking, so improper use will cause heap corruption. Other than ```begin``` and ```end``` methods, a range concept is not yet a part of the standard library. See however [Boost Range v2](http://www.boost.org/doc/libs/release/libs/range/) and the [range-v3 proposal](https://github.com/ericniebler/range-v3). Both implement strided iterators over ranges, but would not be considered light-weight.

```{r}
strided_nth_values(1:1000, 21, 11)
```

A strided range can be used to loop over all elements of an arbitrarily dimensioned array with extents only known at run-time.

```{Rcpp}
// [[Rcpp::depends(BH)]]
// [[Rcpp::depends(strider)]]
// [[Rcpp::plugins(cpp11)]]

#include <vignette.h>

// [[Rcpp::export]]
void strided_loop_range_3(const IntegerVector& a)
{
  IntegerVector d = a.attr("dim");
  if (d.size() != 3) stop("Expecting 3D array");
  for (auto&& x : make_strided_range(&a[0], d[1] * d[2], d[0]))
    for (auto&& y : make_strided_range(&x, d[2], d[1]))
      for (auto&& z : make_strided_range(&y, 1, d[2]))
        Rcout << x << " " << y << " " << z << std::endl;
}
```

Properly constructed, the stride should diminish with each added inner-loop to optimize memory locality.

```{r}
x = 1:(2 * 2 * 2)
dim(x) = c(2, 2, 2)
strided_loop_range_3(x)
```

## Conclusions

Experimenting with the C++ standard library algorithms demonstrates that they are often highly efficient and, in some cases, faster than corresponding native R algorithms. However using the standard library algorithms with multidimensional data is challenging and it is quite common for authors to resort to index-based for-loops, which can impede performance and risk indexing errors.

The **strider** package provides a lightweight pointer-adapter that makes using the standard library algorithms straightforward with multidimensional buffers accessible via a pointer. As long as one knows the dimensions and the memory layout of the data, then any dimension can be scanned by computing a stride and number of strides. When it is possible to scan the data sequentially, maximum performance is attained. Owning to the large number of legacy libraries whose APIs pass raw pointers to structured buffers, I expect that **strider** may find a wide range of applications while also improving code reliability and comprehension.

***


